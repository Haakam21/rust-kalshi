/*
 * Kalshi Trade API
 *
 * This documentation describes Kalshi's trading API (known as Trade API v2). By using this API, you agree to Kalshi's Developer Agreement (https://kalshi.com/developer-agreement).
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@kalshi.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// Market : Contains information about a market. Note: for some fields, you should not assume a fixed structure.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct Market {
    /// If true then this market can close earlier then the time provided on close_time.
    #[serde(rename = "can_close_early")]
    pub can_close_early: bool,
    #[serde(rename = "cap_strike", skip_serializing_if = "Option::is_none")]
    pub cap_strike: Option<f64>,
    /// Category for this market.
    #[serde(rename = "category")]
    pub category: String,
    /// Date and time in the ISO 8601 spec. Example: 2022-11-30T15:00:00Z
    #[serde(rename = "close_time")]
    pub close_time: String,
    /// Expiration value for each target that leads to a YES settlement.  Filled only if \"strike_type\" is \"custom\".
    #[serde(rename = "custom_strike", skip_serializing_if = "Option::is_none")]
    pub custom_strike: Option<std::collections::HashMap<String, serde_json::Value>>,
    /// Unique identifier for events.
    #[serde(rename = "event_ticker")]
    pub event_ticker: String,
    /// Date and time in the ISO 8601 spec. Example: 2022-11-30T15:00:00Z
    #[serde(rename = "expected_expiration_time", skip_serializing_if = "Option::is_none")]
    pub expected_expiration_time: Option<String>,
    /// Date and time in the ISO 8601 spec. Example: 2022-11-30T15:00:00Z
    #[serde(rename = "expiration_time")]
    pub expiration_time: String,
    /// The value that was considered for the settlement.
    #[serde(rename = "expiration_value")]
    pub expiration_value: String,
    /// Date and time in the ISO 8601 spec. Example: 2022-11-30T15:00:00Z
    #[serde(rename = "fee_waiver_expiration_time", skip_serializing_if = "Option::is_none")]
    pub fee_waiver_expiration_time: Option<String>,
    #[serde(rename = "floor_strike", skip_serializing_if = "Option::is_none")]
    pub floor_strike: Option<f64>,
    /// Mapping from expiration values to settlement values of the YES/LONG side, in centi-cents.  Filled only if \"market_type\" is \"scalar\" and \"strike_type\" is \"functional\".  Ex. f(x) = max(0, min(10000, 500 * x))  A scalar market with this functional strike and an expiration value of 10 would have a settlement value on the YES/LONG side of 5000 centi cents.
    #[serde(rename = "functional_strike", skip_serializing_if = "Option::is_none")]
    pub functional_strike: Option<String>,
    /// Price for the last traded yes contract on this market.
    #[serde(rename = "last_price")]
    pub last_price: i64,
    /// Date and time in the ISO 8601 spec. Example: 2022-11-30T15:00:00Z
    #[serde(rename = "latest_expiration_time")]
    pub latest_expiration_time: String,
    /// Value for current offers in this market in cents.
    #[serde(rename = "liquidity")]
    pub liquidity: i64,
    /// Identifies the type of market, which affects its payout and structure.  binary: Every binary market has two sides, YES and NO. If the market's \"payout criterion\" is satisfied, it pays out the notional value to holders of YES. Otherwise, it pays out the notional value to holders of NO.  scalar: Every scalar market has two sides, LONG and SHORT (although these might be referred to as YES/NO in some API endpoints). At settlement, each contract's notional value is split between LONG and SHORT as described in the market rules.
    #[serde(rename = "market_type", deserialize_with = "Option::deserialize")]
    pub market_type: Option<serde_json::Value>,
    /// Price for the lowest NO sell offer on this market.
    #[serde(rename = "no_ask")]
    pub no_ask: i64,
    /// Price for the highest NO buy offer on this market.
    #[serde(rename = "no_bid")]
    pub no_bid: i64,
    /// Shortened title for the no side of this market.
    #[serde(rename = "no_sub_title")]
    pub no_sub_title: String,
    /// The total value of a single contract at settlement.
    #[serde(rename = "notional_value")]
    pub notional_value: i64,
    /// Number of contracts bought on this market disconsidering netting.
    #[serde(rename = "open_interest")]
    pub open_interest: i64,
    /// Date and time in the ISO 8601 spec. Example: 2022-11-30T15:00:00Z
    #[serde(rename = "open_time")]
    pub open_time: String,
    /// Price for the last traded yes contract on this market a day ago.
    #[serde(rename = "previous_price")]
    pub previous_price: i64,
    /// Price for the lowest YES sell offer on this market a day ago.
    #[serde(rename = "previous_yes_ask")]
    pub previous_yes_ask: i64,
    /// Price for the highest YES buy offer on this market a day ago.
    #[serde(rename = "previous_yes_bid")]
    pub previous_yes_bid: i64,
    /// The units used to express all price related fields in this response, including: prices, bids/asks, liquidity, notional and settlement values. usd_cent MONEY_UNIT_USD_CENT usd_centi_cent MONEY_UNIT_USD_CENTI_CENT
    #[serde(rename = "response_price_units")]
    pub response_price_units: ResponsePriceUnits,
    /// Settlement result for this market. Filled only after determination. Omitted for scalar markets.  MARKET_RESULT_NO_RESULT yes MARKET_RESULT_YES no MARKET_RESULT_NO void MARKET_RESULT_VOID all_no RANGED_MARKET_RESULT_ALL_NO all_yes RANGED_MARKET_RESULT_ALL_YES
    #[serde(rename = "result")]
    pub result: Result,
    /// Risk limit for this market in cents.
    #[serde(rename = "risk_limit_cents")]
    pub risk_limit_cents: i64,
    /// A plain language description of the most important market terms.
    #[serde(rename = "rules_primary")]
    pub rules_primary: String,
    /// A plain language description of secondary market terms.
    #[serde(rename = "rules_secondary")]
    pub rules_secondary: String,
    /// The amount of time after determination that the market settles (pays out).
    #[serde(rename = "settlement_timer_seconds")]
    pub settlement_timer_seconds: i32,
    /// The settlement value of the YES/LONG side of the contract. Only filled after determination.
    #[serde(rename = "settlement_value", skip_serializing_if = "Option::is_none")]
    pub settlement_value: Option<i64>,
    /// Represents the current status of a market.
    #[serde(rename = "status", deserialize_with = "Option::deserialize")]
    pub status: Option<serde_json::Value>,
    /// Strike type defines how the market strike (expiration value) is defined and evaluated.  greater: It will be a single number. For YES outcome the expiration value should be greater than \"floor_strike\".  greater_or_equal: It will be a single number. For YES outcome the expiration value should be greater OR EQUAL than \"floor_strike\".  less: It will be a single number. For YES outcome the expiration value should be less than \"cap_strike\".  less_or_equal: It will be a single number. For YES outcome the expiration value should be less OR EQUAL than \"cap_strike\".  between: It will be two numbers. For YES outcome the expiration value should be between inclusive \"floor_strike\" and \"cap_strike\", that means expiration value needs to be greater or equal \"floor_strike\" and less or equal \"cap_strike\".  functional: For scalar markets only. A mapping from expiration values to settlement values of the YES/LONG side will be in \"functional_strike\".  custom: It will be one or more non-numerical values. For YES outcome the expiration values should be equal to the values in \"custom_strike\". unknown MarketStrikeTypeUnknown greater MarketStrikeTypeGreater less MarketStrikeTypeLess greater_or_equal MarketStrikeTypeGreaterOrEqual less_or_equal MarketStrikeTypeLessOrEqual between MarketStrikeTypeBetween functional MarketStrikeTypeFunctional custom MarketStrikeTypeCustom
    #[serde(rename = "strike_type", skip_serializing_if = "Option::is_none")]
    pub strike_type: Option<StrikeType>,
    /// Deprecated: Shortened title for this market. Use \"yes_sub_title\" or \"no_sub_title\" instead.
    #[serde(rename = "subtitle")]
    pub subtitle: String,
    /// The minimum price movement in the market. All limit order prices must be in denominations of the tick size.
    #[serde(rename = "tick_size")]
    pub tick_size: i64,
    /// Unique identifier for markets.
    #[serde(rename = "ticker")]
    pub ticker: String,
    /// Full title describing this market.
    #[serde(rename = "title")]
    pub title: String,
    /// Number of contracts bought on this market.
    #[serde(rename = "volume")]
    pub volume: i64,
    /// Number of contracts bought on this market in the past day.
    #[serde(rename = "volume_24h")]
    pub volume_24h: i64,
    /// Price for the lowest YES sell offer on this market.
    #[serde(rename = "yes_ask")]
    pub yes_ask: i64,
    /// Price for the highest YES buy offer on this market.
    #[serde(rename = "yes_bid")]
    pub yes_bid: i64,
    /// Shortened title for the yes side of this market.
    #[serde(rename = "yes_sub_title")]
    pub yes_sub_title: String,
}

impl Market {
    /// Contains information about a market. Note: for some fields, you should not assume a fixed structure.
    pub fn new(can_close_early: bool, category: String, close_time: String, event_ticker: String, expiration_time: String, expiration_value: String, last_price: i64, latest_expiration_time: String, liquidity: i64, market_type: Option<serde_json::Value>, no_ask: i64, no_bid: i64, no_sub_title: String, notional_value: i64, open_interest: i64, open_time: String, previous_price: i64, previous_yes_ask: i64, previous_yes_bid: i64, response_price_units: ResponsePriceUnits, result: Result, risk_limit_cents: i64, rules_primary: String, rules_secondary: String, settlement_timer_seconds: i32, status: Option<serde_json::Value>, subtitle: String, tick_size: i64, ticker: String, title: String, volume: i64, volume_24h: i64, yes_ask: i64, yes_bid: i64, yes_sub_title: String) -> Market {
        Market {
            can_close_early,
            cap_strike: None,
            category,
            close_time,
            custom_strike: None,
            event_ticker,
            expected_expiration_time: None,
            expiration_time,
            expiration_value,
            fee_waiver_expiration_time: None,
            floor_strike: None,
            functional_strike: None,
            last_price,
            latest_expiration_time,
            liquidity,
            market_type,
            no_ask,
            no_bid,
            no_sub_title,
            notional_value,
            open_interest,
            open_time,
            previous_price,
            previous_yes_ask,
            previous_yes_bid,
            response_price_units,
            result,
            risk_limit_cents,
            rules_primary,
            rules_secondary,
            settlement_timer_seconds,
            settlement_value: None,
            status,
            strike_type: None,
            subtitle,
            tick_size,
            ticker,
            title,
            volume,
            volume_24h,
            yes_ask,
            yes_bid,
            yes_sub_title,
        }
    }
}
/// The units used to express all price related fields in this response, including: prices, bids/asks, liquidity, notional and settlement values. usd_cent MONEY_UNIT_USD_CENT usd_centi_cent MONEY_UNIT_USD_CENTI_CENT
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ResponsePriceUnits {
    #[serde(rename = "usd_cent")]
    Cent,
    #[serde(rename = "usd_centi_cent")]
    CentiCent,
}

impl Default for ResponsePriceUnits {
    fn default() -> ResponsePriceUnits {
        Self::Cent
    }
}
/// Settlement result for this market. Filled only after determination. Omitted for scalar markets.  MARKET_RESULT_NO_RESULT yes MARKET_RESULT_YES no MARKET_RESULT_NO void MARKET_RESULT_VOID all_no RANGED_MARKET_RESULT_ALL_NO all_yes RANGED_MARKET_RESULT_ALL_YES
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Result {
    #[serde(rename = "")]
    Empty,
    #[serde(rename = "yes")]
    Yes,
    #[serde(rename = "no")]
    No,
    #[serde(rename = "void")]
    Void,
    #[serde(rename = "all_no")]
    AllNo,
    #[serde(rename = "all_yes")]
    AllYes,
}

impl Default for Result {
    fn default() -> Result {
        Self::Empty
    }
}
/// Strike type defines how the market strike (expiration value) is defined and evaluated.  greater: It will be a single number. For YES outcome the expiration value should be greater than \"floor_strike\".  greater_or_equal: It will be a single number. For YES outcome the expiration value should be greater OR EQUAL than \"floor_strike\".  less: It will be a single number. For YES outcome the expiration value should be less than \"cap_strike\".  less_or_equal: It will be a single number. For YES outcome the expiration value should be less OR EQUAL than \"cap_strike\".  between: It will be two numbers. For YES outcome the expiration value should be between inclusive \"floor_strike\" and \"cap_strike\", that means expiration value needs to be greater or equal \"floor_strike\" and less or equal \"cap_strike\".  functional: For scalar markets only. A mapping from expiration values to settlement values of the YES/LONG side will be in \"functional_strike\".  custom: It will be one or more non-numerical values. For YES outcome the expiration values should be equal to the values in \"custom_strike\". unknown MarketStrikeTypeUnknown greater MarketStrikeTypeGreater less MarketStrikeTypeLess greater_or_equal MarketStrikeTypeGreaterOrEqual less_or_equal MarketStrikeTypeLessOrEqual between MarketStrikeTypeBetween functional MarketStrikeTypeFunctional custom MarketStrikeTypeCustom
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum StrikeType {
    #[serde(rename = "unknown")]
    Unknown,
    #[serde(rename = "greater")]
    Greater,
    #[serde(rename = "less")]
    Less,
    #[serde(rename = "greater_or_equal")]
    GreaterOrEqual,
    #[serde(rename = "less_or_equal")]
    LessOrEqual,
    #[serde(rename = "between")]
    Between,
    #[serde(rename = "functional")]
    Functional,
    #[serde(rename = "custom")]
    Custom,
}

impl Default for StrikeType {
    fn default() -> StrikeType {
        Self::Unknown
    }
}

